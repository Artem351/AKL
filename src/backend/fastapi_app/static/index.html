<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>Система локализации платы</title>
    <style>
      body {
        margin: 0;
        font-family: Segoe UI, sans-serif;
        background: #f4f6f9;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .map {
        margin-top: 20px;
        background: #fff;
        border: 2px solid #ddd;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        padding: 16px;
      }
      .map__controls {
        text-align: center;
        margin-bottom: 12px;
      }
      .map__button {
        margin: 4px;
        padding: 8px 14px;
        border: 0;
        border-radius: 6px;
        color: #fff;
        font-size: 14px;
        cursor: pointer;
      }
      .map__button_start {
        background: #27ae60;
      }
      .map__button_finish {
        background: #7f8c8d;
      }
      .map__button_export {
        background: #9b59b6;
      }
      .map__container {
        display: flex;
        justify-content: center;
        align-items: center;
      }
      canvas {
        background: #fff;
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <div class="map">
      <div class="map__controls">
        <button class="map__button map__button_start" onclick="startRoute()">
          Начать маршрут
        </button>
        <button class="map__button map__button_finish" onclick="stopRoute()">
          Завершить маршрут
        </button>
        <button class="map__button map__button_export" onclick="exportRoute()">
          Выгрузить (txt)
        </button>
      </div>
      <div class="map__container">
        <canvas id="mapCanvas" width="700" height="700"></canvas>
      </div>
    </div>

    <script>
      const cvs = document.getElementById("mapCanvas");
      const ctx = cvs.getContext("2d");

      let beacons = {};
      let board = { x: 0, y: 0 },
        route = [],
        timer = null;
      let scale = 20,
        offsetX = cvs.width / 2,
        offsetY = cvs.height / 2;

      function mapFromApi(raw) {
        let out = {};
        if (!raw) return out;
        if (Array.isArray(raw.beacons)) {
          raw.beacons.forEach((b) => {
            if (b && b.id != null && b.x != null && b.y != null)
              out[String(b.id)] = {
                x: +b.x,
                y: +b.y,
                name: b.name || "beacon_" + b.id,
              };
          });
          return out;
        }
        if (typeof raw === "object") {
          for (const k of Object.keys(raw)) {
            const v = raw[k];
            if (v && v.x != null && v.y != null)
              out[String(k)] = {
                x: +v.x,
                y: +v.y,
                name: v.name || "beacon_" + k,
              };
          }
        }
        return out;
      }

      function computeTransform() {
        const ids = Object.keys(beacons);
        if (ids.length === 0) {
          scale = 20;
          offsetX = cvs.width / 2;
          offsetY = cvs.height / 2;
          return;
        }
        const xs = ids.map((i) => beacons[i].x);
        const ys = ids.map((i) => beacons[i].y);
        const minX = Math.min(...xs, board.x),
          maxX = Math.max(...xs, board.x);
        const minY = Math.min(...ys, board.y),
          maxY = Math.max(...ys, board.y);
        const maxRange = Math.max(
          Math.abs(minX),
          Math.abs(maxX),
          Math.abs(minY),
          Math.abs(maxY),
          0.0001
        );
        const padding = 40;
        const half = Math.min(cvs.width, cvs.height) / 2 - padding;
        scale = half / maxRange;
        if (!isFinite(scale) || scale <= 0) scale = 20;
        offsetX = cvs.width / 2;
        offsetY = cvs.height / 2;
      }

      function toCanvas(p) {
        return { x: offsetX + p.x * scale, y: offsetY - p.y * scale };
      }

      function drawAll() {
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        if (Object.keys(beacons).length === 0) {
          ctx.strokeStyle = "#34495e";
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(0, cvs.height / 2);
          ctx.lineTo(cvs.width, cvs.height / 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cvs.width / 2, 0);
          ctx.lineTo(cvs.width / 2, cvs.height);
          ctx.stroke();
          ctx.fillStyle = "#34495e";
          ctx.fillText("Нет маяков", 10, 20);
          return;
        }

        const CELL_SIZE = 40; // крупная сетка

        // grid (тонкая светлая)
        ctx.strokeStyle = "#ecf0f1";
        ctx.lineWidth = 1;
        let startX = offsetX % CELL_SIZE;
        for (let x = startX; x <= cvs.width; x += CELL_SIZE) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, cvs.height);
          ctx.stroke();
        }
        for (let x = startX - CELL_SIZE; x >= 0; x -= CELL_SIZE) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, cvs.height);
          ctx.stroke();
        }
        let startY = offsetY % CELL_SIZE;
        for (let y = startY; y <= cvs.height; y += CELL_SIZE) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(cvs.width, y);
          ctx.stroke();
        }
        for (let y = startY - CELL_SIZE; y >= 0; y -= CELL_SIZE) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(cvs.width, y);
          ctx.stroke();
        }

        // axes (жирные и тёмные)
        ctx.strokeStyle = "#34495e";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, offsetY);
        ctx.lineTo(cvs.width, offsetY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(offsetX, 0);
        ctx.lineTo(offsetX, cvs.height);
        ctx.stroke();
        ctx.fillStyle = "#34495e";
        ctx.fillText("X", cvs.width - 20, offsetY - 5);
        ctx.fillText("Y", offsetX + 10, 15);

        // beacons
        ctx.font = "bold 12px Segoe UI";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (const id of Object.keys(beacons)) {
          const b = beacons[id];
          const c = toCanvas(b);
          ctx.beginPath();
          ctx.arc(c.x, c.y, 12, 0, Math.PI * 2);
          ctx.fillStyle = "#f39c12";
          ctx.fill();
          ctx.strokeStyle = "#e67e22";
          ctx.lineWidth = 1.5;
          ctx.stroke();
          ctx.fillStyle = "#fff";
          ctx.fillText(id, c.x, c.y);
        }

        // route
        if (route.length > 1) {
          ctx.beginPath();
          const f = toCanvas(route[0]);
          ctx.moveTo(f.x, f.y);
          for (let i = 1; i < route.length; i++) {
            const p = toCanvas(route[i]);
            ctx.lineTo(p.x, p.y);
          }
          ctx.strokeStyle = "#2980b9";
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // board
        const cb = toCanvas(board);
        ctx.beginPath();
        ctx.arc(cb.x, cb.y, 10, 0, Math.PI * 2);
        ctx.fillStyle = "#2980b9";
        ctx.fill();
        ctx.strokeStyle = "rgba(41,128,185,0.4)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(cb.x, cb.y, 16, 0, Math.PI * 2);
        ctx.stroke();
      }

      async function fetchBeacons() {
        try {
          const r = await fetch("/api/beacons");
          if (!r.ok) throw new Error("status " + r.status);
          const json = await r.json();
          beacons = mapFromApi(json);
          computeTransform();
          drawAll();
          return true;
        } catch (err) {
          console.error("beacons fetch error", err);
          return false;
        }
      }

      async function startRoute() {
        if (timer) return;
        try {
          const resp = await fetch("/api/start_way", { method: "POST" });
          if (!resp.ok) {
            alert("Ошибка запуска маршрута");
            return;
          }
        } catch (err) {
          console.error(err);
          return;
        }

        // Начало нового маршрута
        route = [];
        board = { x: 0, y: 0 };
        computeTransform();
        drawAll(); // сразу обновляем карту

        timer = setInterval(async () => {
          try {
            const r = await fetch("/api/get_positions_1?test=1");
            const j = await r.json();
            if (j.positions && j.positions.length) {
              const newPositions = j.positions
                .slice(route.length)
                .map((p) => ({ x: +p.x, y: +p.y }));
              route.push(...newPositions);
              if (route.length) board = route[route.length - 1];
              computeTransform();
              drawAll();
            }
          } catch (e) {
            console.error("pos fetch error", e);
          }
        }, 2000);
      }

      async function stopRoute() {
        if (!timer) return;
        clearInterval(timer);
        timer = null;
        try {
          const resp = await fetch("/api/finish_way", { method: "POST" });
          if (!resp.ok) {
            alert("Ошибка завершения маршрута");
            return;
          }
          alert("Маршрут завершён");
        } catch (err) {
          console.error(err);
          alert("Ошибка завершения маршрута");
        }
      }

      function exportRoute() {
        if (!route.length) return alert("Маршрут пуст");
        let txt =
          "X;Y\n" +
          route
            .map(
              (p) =>
                `${p.x.toFixed(1).replace(".", ",")};${p.y
                  .toFixed(1)
                  .replace(".", ",")}`
            )
            .join("\n");
        const a = document.createElement("a");
        a.href = URL.createObjectURL(new Blob([txt], { type: "text/plain" }));
        a.download = "route.txt";
        a.click();
      }

      window.addEventListener("error", (e) => console.error("window error", e));

      (async function init() {
        await fetchBeacons();
        setInterval(fetchBeacons, 5000);
      })();
    </script>
  </body>
</html>
